# Story 4.3: Control Grouping & Dynamic Disabling - Tokenized Design System & Theming

## Status
Not Done (Significantly expanded)

## Context & Problem Statement
Previous iterations have highlighted a lack of a standardized, maintainable approach to UI styling and behavior, leading to:
*   **Regressions:** Repeated issues with component rendering (e.g., button labels disappearing) and conditional UI logic (e.g., dynamic input disabling).
*   **Inconsistent Styling:** Ad-hoc color definitions and styling within `ui.rs`, making adaptive theming and global style changes difficult and error-prone.
*   **Inefficient Development:** Constant re-evaluation and rebuilding of UI elements rather than leveraging a systematic approach.

This expanded story addresses these issues by introducing a robust, tokenized design system built upon `iced`'s theming capabilities, ensuring consistency, maintainability, and proper adaptive theming.

## Goals
**As a** user,
**I want** related controls to be visually grouped, clearly styled according to a consistent design system, and non-essential settings to be dynamically disabled/rendered differently while the clicker is running,
**so that** the UI is organized, visually appealing, adaptive to system themes, and I'm prevented from making accidental changes or encountering UI bugs during operation.

## Acceptance Criteria (Expanded)
1.  **Tokenized Design System Implementation:**
    *   A dedicated `theme.rs` module is introduced to define a custom `iced::Theme` or extend the default `Theme` with explicit design tokens (colors, spacing, font sizes) for both Light and Dark modes.
    *   All UI element styling (colors, backgrounds, borders, text, disabled states) across the application *must* derive from these defined design tokens. Direct `Color::from_rgb` calls for themable elements are eliminated in `ui.rs`.
    *   `iced::widget::button::Status`, `iced::widget::text_input::Status`, `iced::widget::pick_list::Status`, and `iced::widget::checkbox::Status` are correctly implemented to reflect the design tokens for active, hovered, pressed, and disabled states.

2.  **Visual Grouping & Containers:**
    *   **Primary Controls Group:** Visually grouped within a distinct, rounded-corner container (`iced::widget::container` with custom style) with a background color token that subtly differentiates it from the main window.
    *   **Hotkey Configuration Group:** Similarly grouped within its own distinct, rounded-corner container, matching the styling of the Primary Controls Group.

3.  **Dynamic Disabling & Read-Only Display:**
    *   When the auto-clicker is "RUNNING", all interactive UI elements (inputs, dropdowns, checkboxes, Start/Stop buttons based on state) are **disabled**.
    *   Interactive `TextInput` for "Click Interval (ms)" and `PickList` for "Mouse Button" are conditionally replaced or styled as **read-only `Text` widgets** when the clicker is "RUNNING". Their current values are displayed clearly, e.g., "[100]" and "[Left]". This explicitly addresses the regression and requirement for readability.
    *   Disabled elements (including text, icons, and backgrounds) visually conform to the specified WCAG AA contrast ratios in both Light and Dark modes, leveraging design tokens for disabled states.

4.  **Buttons (Start/Stop) - Enhanced Styling & Icons:**
    *   "Start" and "Stop" buttons leverage custom `iced::widget::button` styling to incorporate icons (Play for Start, Square for Stop) alongside text labels.
    *   Buttons are large, rectangular, and feature significantly rounded corners as per `reference_ui.jpg`.
    *   Button colors (background, icon, text) are dynamically applied from design tokens based on their enabled/disabled state and the current theme.
    *   Only the "Start" button is enabled when "STOPPED", and only the "Stop" button is enabled when "RUNNING". Their disabled state is visually distinct.

5.  **Status Display:**
    *   The "Status: RUNNING/STOPPED" display uses a button-like container with rounded corners.
    *   Its background and text colors are sourced from design tokens specific to "Status: RUNNING" (green) and "Status: STOPPED" (neutral grey) states, adapting correctly to the current theme.

6.  **Hotkey Configuration Elements:**
    *   **Modifier Checkboxes (Ctrl, Alt, Shift):** Visually styled using design tokens for their checked/unchecked and enabled/disabled states.
    *   **Primary Key Display:** Displays the assigned key (e.g., "[F6]") within a compact, read-only field (likely a styled `Text` widget or custom component), adapting to theme.
    *   All hotkey configuration elements are disabled when the clicker is "RUNNING".

7.  **Adaptive Theming & Consistency:**
    *   The entire UI seamlessly adapts between Light and Dark modes based on the system setting, with all colors, backgrounds, and text deriving from the chosen theme's design tokens.
    *   Icons for labels (e.g., next to "Click Interval (ms):", "Mouse Button:") are consistently rendered and adapt to the theme.

## Tasks / Subtasks (Revised & Detailed)

### Phase 1: Establish Design System Foundations (Theme Tokens)
- [x] **1.1 Define Custom `iced::Theme` or Extend Default:**
    - [x] Create a new module `super_clicker/src/theme.rs`.
    - [x] Within `theme.rs`, define a custom `AppTheme` enum that wraps `iced::Theme` or creates a new theme struct.
    - [x] Implement `From<AppTheme> for iced::Theme` to allow seamless use.
    - [x] Implement the `iced::widget::container::StyleSheet` trait for `AppTheme` to define card-like backgrounds for grouped controls (e.g., `PrimaryControlsContainer`, `HotkeyConfigContainer`).
    - [x] Implement `iced::widget::button::StyleSheet` for `AppTheme` to define button styles for `PrimaryButton` (Start/Stop), `StatusButton` (Status Display), and `IconButton` (if separate icon-only buttons are needed).
    - [x] Implement `iced::widget::text_input::StyleSheet`, `iced::widget::pick_list::StyleSheet`, `iced::widget::checkbox::StyleSheet` for `AppTheme` to ensure all form elements are styled using tokens and handle disabled states.
    - [x] **Define Color Design Tokens:**
        - [x] Within `theme.rs` (or a sub-module like `theme::colors`), explicitly define constants or functions returning `iced::Color` for:
            - `ACCENT_BLUE`: `#0078D4` (Windows accent blue)
            - `STATUS_RUNNING_GREEN`: `#4CAF50`
            - `STATUS_STOPPED_GREY_LIGHT`: Light grey for Light Mode (e.g., `#A0A0A0` background, dark text)
            - `STATUS_STOPPED_GREY_DARK`: Dark grey for Dark Mode (e.g., a desaturated dark background, light text)
            - `PRIMARY_BACKGROUND_LIGHT`, `PRIMARY_BACKGROUND_DARK`
            - `CARD_BACKGROUND_LIGHT`, `CARD_BACKGROUND_DARK` (for grouped controls)
            - `TEXT_PRIMARY_LIGHT`, `TEXT_PRIMARY_DARK`
            - `TEXT_DISABLED_LIGHT`, `TEXT_DISABLED_DARK`
            - `INPUT_BACKGROUND_LIGHT`, `INPUT_BACKGROUND_DARK`
            - `INPUT_BORDER_LIGHT`, `INPUT_BORDER_DARK`
            - `BUTTON_PRIMARY_BACKGROUND_LIGHT`, `BUTTON_PRIMARY_BACKGROUND_DARK` (active state)
            - `BUTTON_DISABLED_BACKGROUND_LIGHT`, `BUTTON_DISABLED_BACKGROUND_DARK`
            - `BUTTON_TEXT_PRIMARY_LIGHT`, `BUTTON_TEXT_PRIMARY_DARK`
            - `BUTTON_TEXT_DISABLED_LIGHT`, `BUTTON_TEXT_DISABLED_DARK`
            - And similar for borders, hover states, etc., ensuring each token has a specific value for both Light and Dark modes.
    - [x] **Define Spacing Design Tokens:**
        - [x] Define constants for consistent padding and spacing values (e.g., `SPACING_SM`, `SPACING_MD`, `SPACING_LG`).
- [x] **1.2 Update `app.rs` for Custom Theme Integration:**
    - [x] Modify `SuperClicker::new` to initialize `current_theme` with `AppTheme::Light` or `AppTheme::Dark` based on `dark_light::detect()`.
    - [x] Update `SuperClicker::theme` to return the `iced::Theme` derived from `self.current_theme: AppTheme`.
    - [x] Update `Message::ThemeChanged` to accept and set `AppTheme`.

### Phase 2: Refactor UI Components with Design System
- [ ] **2.1 Implement `ui.rs` to Use Custom Stylesheets:**
    - [ ] Remove all direct `Color::from_rgb` calls.
    - [ ] Refactor button definitions (`start_btn`, `stop_btn`) to use `button().style(AppTheme::PrimaryButton)` or similar, ensuring they integrate text and icon content. This will likely require creating a helper function for icon buttons.
    - [ ] Wrap primary controls and hotkey configuration in `iced::widget::container` and apply `container().style(AppTheme::CardContainer)`.
    - [ ] Apply specific styles for `text_input`, `pick_list`, and `checkbox` using `style(AppTheme::TextInput)` etc.

- [ ] **2.2 Implement Dynamic Disabling & Read-Only Display Logic in `ui.rs`:**
    - [ ] Modify the `view` function to accept `is_running: bool` parameter.
    - [ ] Conditionally render `text_input` for interval:
        - If `is_running` is true: render as a styled `text` widget displaying `[interval_input]`.
        - If `is_running` is false: render as a styled `text_input` widget.
    - [ ] Conditionally render `pick_list` for mouse button:
        - If `is_running` is true: render as a styled `text` widget displaying `[mouse_button_selected]`.
        - If `is_running` is false: render as a styled `pick_list` widget.
    - [ ] Set `is_enabled` property (or similar in `iced`) for checkboxes and buttons based on `is_running` and specific button logic.
    - [ ] Ensure all disabled states correctly apply the disabled styling from the `AppTheme`.

- [ ] **2.3 Enhance Buttons (Start/Stop) with Icons and Text:**
    - [ ] Create helper functions or custom widgets within `ui.rs` (or a sub-module like `ui::components`) to construct buttons that combine an icon and text, styled according to `AppTheme::PrimaryButton`.
    - [ ] Replace existing `start_btn` and `stop_btn` with these enhanced versions.

- [ ] **2.4 Implement Status Display Styling:**
    - [ ] Refactor the status text and its container to use `container().style(AppTheme::StatusButton)` for its background and text colors, dynamically chosen based on `is_running` state from design tokens.

- [ ] **2.5 Implement Hotkey Configuration Element Styling:**
    - [ ] Apply `checkbox().style(AppTheme::Checkbox)` for modifier checkboxes.
    - [ ] Style the primary key display (e.g., `[F6]`) using theme tokens.

### Phase 3: Validation & Refinement
- [ ] **3.1 Manual Testing & Visual Verification:**
    - [ ] Verify all UI elements are correctly grouped and styled in both Light and Dark modes.
    - [ ] Test dynamic disabling: Ensure controls become disabled/read-only when running and enabled when stopped.
    - [ ] Check button functionality (Start/Stop) and visual feedback.
    - [ ] Verify hotkey configuration elements are disabled when running.
- [ ] **3.2 WCAG AA Compliance Check:**
    - [ ] Perform manual contrast checks for text and interactive elements in all states (active, disabled) and both themes.
    - [ ] Ensure keyboard navigation and focus indicators are correct.
- [ ] **3.3 Code Review:**
    - [ ] Conduct a thorough code review to ensure adherence to the new design system, proper use of theme tokens, and elimination of direct color/style declarations.

## Dev Notes
- Refer to `docs/front-end-spec.md` (updated) for specific visual details and behavior.
- Leverage `iced`'s `style` methods on widgets (`.style(theme_variant)`) and custom `StyleSheet` implementations for each widget type in `theme.rs`.
- The `is_running` flag in `app.rs`'s `Model` is the single source of truth for UI element state.
- Icons can be integrated into buttons using `iced::widget::Row` or a custom component that combines `iced::widget::text` (for icon font, if used) and `iced::widget::text`.
- For `Text` widgets that are dynamically replacing `TextInput` or `PickList`, ensure appropriate padding and alignment to maintain layout consistency.

## File List
- super_clicker/src/theme.rs
